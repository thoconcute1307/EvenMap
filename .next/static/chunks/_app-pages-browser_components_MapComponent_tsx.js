"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_components_MapComponent_tsx"],{

/***/ "(app-pages-browser)/./components/MapComponent.tsx":
/*!*************************************!*\
  !*** ./components/MapComponent.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MapComponent; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\nfunction MapComponent(param) {\n    let { events, onEventClick, center, zoom = 10 } = param;\n    _s();\n    const mapRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const mapInstanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const markersRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([]);\n    const mapLoadedRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const addMarkersToMap = (map)=>{\n        // Clear existing markers first\n        markersRef.current.forEach((marker)=>marker.remove());\n        markersRef.current = [];\n        events.forEach((event)=>{\n            if (event.latitude && event.longitude) {\n                // Create a DOM element for the marker\n                const el = document.createElement(\"div\");\n                el.className = \"event-marker\";\n                el.style.width = \"30px\";\n                el.style.height = \"30px\";\n                el.style.borderRadius = \"50%\";\n                el.style.backgroundColor = \"#ef4444\";\n                el.style.border = \"3px solid white\";\n                el.style.cursor = \"pointer\";\n                el.style.boxShadow = \"0 2px 4px rgba(0,0,0,0.3)\";\n                // Create marker\n                const marker = new window.mapboxgl.Marker(el).setLngLat([\n                    event.longitude,\n                    event.latitude\n                ]).setPopup(new window.mapboxgl.Popup({\n                    offset: 25\n                }).setHTML('<div style=\"padding: 8px;\"><strong>'.concat(event.name, \"</strong><br/>\").concat(event.location, \"</div>\"))).addTo(map);\n                // Add click event\n                el.addEventListener(\"click\", ()=>{\n                    onEventClick === null || onEventClick === void 0 ? void 0 : onEventClick(event);\n                });\n                markersRef.current.push(marker);\n            }\n        });\n    };\n    // Initialize map once\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (!mapRef.current || mapInstanceRef.current) return;\n        const apiKey = \"pk.eyJ1IjoibmluamFzY2hvb2wzNyIsImEiOiJjbWs5dWFsN28xdnBqM2VvdTF1dm15dzR2In0.LnfhFNg9JrGVOWdGWjE4KA\" || 0;\n        const defaultCenter = center || {\n            lat: 10.8231,\n            lng: 106.6297\n        }; // Ho Chi Minh City\n        const loadMapbox = ()=>{\n            // Load Mapbox GL CSS and JS\n            if (!document.getElementById(\"mapbox-gl-css\")) {\n                const css = document.createElement(\"link\");\n                css.id = \"mapbox-gl-css\";\n                css.href = \"https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css\";\n                css.rel = \"stylesheet\";\n                document.head.appendChild(css);\n            }\n            if (!window.mapboxgl) {\n                const script = document.createElement(\"script\");\n                script.src = \"https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js\";\n                script.async = true;\n                document.head.appendChild(script);\n                script.onload = ()=>{\n                    initMapbox();\n                };\n            } else {\n                initMapbox();\n            }\n        };\n        const initMapbox = ()=>{\n            if (!window.mapboxgl || !mapRef.current) return;\n            // Set access token\n            if (apiKey) {\n                window.mapboxgl.accessToken = apiKey;\n            }\n            // Initialize map\n            const map = new window.mapboxgl.Map({\n                container: mapRef.current,\n                style: \"mapbox://styles/mapbox/streets-v12\",\n                center: [\n                    defaultCenter.lng,\n                    defaultCenter.lat\n                ],\n                zoom: zoom\n            });\n            mapInstanceRef.current = map;\n            // Wait for map to load\n            map.on(\"load\", ()=>{\n                mapLoadedRef.current = true;\n                addMarkersToMap(map);\n            });\n        };\n        loadMapbox();\n        return ()=>{\n            // Cleanup markers and map\n            markersRef.current.forEach((marker)=>{\n                marker.remove();\n            });\n            markersRef.current = [];\n            if (mapInstanceRef.current) {\n                mapInstanceRef.current.remove();\n                mapInstanceRef.current = null;\n                mapLoadedRef.current = false;\n            }\n        };\n    }, []); // Only run once on mount\n    // Update markers when events change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (mapInstanceRef.current && mapLoadedRef.current) {\n            addMarkersToMap(mapInstanceRef.current);\n        }\n    }, [\n        events,\n        onEventClick\n    ]);\n    // Update map center and zoom when props change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (mapInstanceRef.current && center && mapLoadedRef.current) {\n            mapInstanceRef.current.flyTo({\n                center: [\n                    center.lng,\n                    center.lat\n                ],\n                zoom: zoom,\n                duration: 1000\n            });\n        }\n    }, [\n        center,\n        zoom\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: mapRef,\n        className: \"w-full h-full\",\n        style: {\n            minHeight: \"400px\"\n        }\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\kudot\\\\Downloads\\\\EventMapWeb\\\\components\\\\MapComponent.tsx\",\n        lineNumber: 146,\n        columnNumber: 10\n    }, this);\n}\n_s(MapComponent, \"KJVOGXe5llB5y1L697ylwxvbhjY=\");\n_c = MapComponent;\nvar _c;\n$RefreshReg$(_c, \"MapComponent\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvTWFwQ29tcG9uZW50LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFMEM7QUFVM0IsU0FBU0UsYUFBYSxLQUE4RDtRQUE5RCxFQUFFQyxNQUFNLEVBQUVDLFlBQVksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUUsRUFBcUIsR0FBOUQ7O0lBQ25DLE1BQU1DLFNBQVNOLDZDQUFNQSxDQUFpQjtJQUN0QyxNQUFNTyxpQkFBaUJQLDZDQUFNQSxDQUFNO0lBQ25DLE1BQU1RLGFBQWFSLDZDQUFNQSxDQUFRLEVBQUU7SUFDbkMsTUFBTVMsZUFBZVQsNkNBQU1BLENBQVU7SUFFckMsTUFBTVUsa0JBQWtCLENBQUNDO1FBQ3ZCLCtCQUErQjtRQUMvQkgsV0FBV0ksT0FBTyxDQUFDQyxPQUFPLENBQUMsQ0FBQ0MsU0FBV0EsT0FBT0MsTUFBTTtRQUNwRFAsV0FBV0ksT0FBTyxHQUFHLEVBQUU7UUFFdkJWLE9BQU9XLE9BQU8sQ0FBQyxDQUFDRztZQUNkLElBQUlBLE1BQU1DLFFBQVEsSUFBSUQsTUFBTUUsU0FBUyxFQUFFO2dCQUNyQyxzQ0FBc0M7Z0JBQ3RDLE1BQU1DLEtBQUtDLFNBQVNDLGFBQWEsQ0FBQztnQkFDbENGLEdBQUdHLFNBQVMsR0FBRztnQkFDZkgsR0FBR0ksS0FBSyxDQUFDQyxLQUFLLEdBQUc7Z0JBQ2pCTCxHQUFHSSxLQUFLLENBQUNFLE1BQU0sR0FBRztnQkFDbEJOLEdBQUdJLEtBQUssQ0FBQ0csWUFBWSxHQUFHO2dCQUN4QlAsR0FBR0ksS0FBSyxDQUFDSSxlQUFlLEdBQUc7Z0JBQzNCUixHQUFHSSxLQUFLLENBQUNLLE1BQU0sR0FBRztnQkFDbEJULEdBQUdJLEtBQUssQ0FBQ00sTUFBTSxHQUFHO2dCQUNsQlYsR0FBR0ksS0FBSyxDQUFDTyxTQUFTLEdBQUc7Z0JBRXJCLGdCQUFnQjtnQkFDaEIsTUFBTWhCLFNBQVMsSUFBSWlCLE9BQU9DLFFBQVEsQ0FBQ0MsTUFBTSxDQUFDZCxJ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LEdBQUc7UUFBQ1Y7UUFBUUM7S0FBYTtJQUV6QiwrQ0FBK0M7SUFDL0NKLGdEQUFTQSxDQUFDO1FBQ1IsSUFBSVEsZUFBZUssT0FBTyxJQUFJUixVQUFVSyxhQUFhRyxPQUFPLEVBQUU7WUFDNURMLGVBQWVLLE9BQU8sQ0FBQ3dELEtBQUssQ0FBQztnQkFDM0JoRSxRQUFRO29CQUFDQSxPQUFPOEMsR0FBRztvQkFBRTlDLE9BQU82QyxHQUFHO2lCQUFDO2dCQUNoQzVDLE1BQU1BO2dCQUNOZ0UsVUFBVTtZQUNaO1FBQ0Y7SUFDRixHQUFHO1FBQUNqRTtRQUFRQztLQUFLO0lBRWpCLHFCQUFPLDhEQUFDaUU7UUFBSUMsS0FBS2pFO1FBQVFnQixXQUFVO1FBQWdCQyxPQUFPO1lBQUVpRCxXQUFXO1FBQVE7Ozs7OztBQUNqRjtHQXRJd0J2RTtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9jb21wb25lbnRzL01hcENvbXBvbmVudC50c3g/YjUxMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuaW1wb3J0IHsgRXZlbnQgfSBmcm9tICdAL3R5cGVzL2V2ZW50JztcclxuXHJcbmludGVyZmFjZSBNYXBDb21wb25lbnRQcm9wcyB7XHJcbiAgZXZlbnRzOiBFdmVudFtdO1xyXG4gIG9uRXZlbnRDbGljaz86IChldmVudDogRXZlbnQpID0+IHZvaWQ7XHJcbiAgY2VudGVyPzogeyBsYXQ6IG51bWJlcjsgbG5nOiBudW1iZXIgfTtcclxuICB6b29tPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXBDb21wb25lbnQoeyBldmVudHMsIG9uRXZlbnRDbGljaywgY2VudGVyLCB6b29tID0gMTAgfTogTWFwQ29tcG9uZW50UHJvcHMpIHtcclxuICBjb25zdCBtYXBSZWYgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IG1hcEluc3RhbmNlUmVmID0gdXNlUmVmPGFueT4obnVsbCk7XHJcbiAgY29uc3QgbWFya2Vyc1JlZiA9IHVzZVJlZjxhbnlbXT4oW10pO1xyXG4gIGNvbnN0IG1hcExvYWRlZFJlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIGNvbnN0IGFkZE1hcmtlcnNUb01hcCA9IChtYXA6IGFueSkgPT4ge1xyXG4gICAgLy8gQ2xlYXIgZXhpc3RpbmcgbWFya2VycyBmaXJzdFxyXG4gICAgbWFya2Vyc1JlZi5jdXJyZW50LmZvckVhY2goKG1hcmtlcikgPT4gbWFya2VyLnJlbW92ZSgpKTtcclxuICAgIG1hcmtlcnNSZWYuY3VycmVudCA9IFtdO1xyXG5cclxuICAgIGV2ZW50cy5mb3JFYWNoKChldmVudCkgPT4ge1xyXG4gICAgICBpZiAoZXZlbnQubGF0aXR1ZGUgJiYgZXZlbnQubG9uZ2l0dWRlKSB7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgRE9NIGVsZW1lbnQgZm9yIHRoZSBtYXJrZXJcclxuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIGVsLmNsYXNzTmFtZSA9ICdldmVudC1tYXJrZXInO1xyXG4gICAgICAgIGVsLnN0eWxlLndpZHRoID0gJzMwcHgnO1xyXG4gICAgICAgIGVsLnN0eWxlLmhlaWdodCA9ICczMHB4JztcclxuICAgICAgICBlbC5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNTAlJztcclxuICAgICAgICBlbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2VmNDQ0NCc7XHJcbiAgICAgICAgZWwuc3R5bGUuYm9yZGVyID0gJzNweCBzb2xpZCB3aGl0ZSc7XHJcbiAgICAgICAgZWwuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xyXG4gICAgICAgIGVsLnN0eWxlLmJveFNoYWRvdyA9ICcwIDJweCA0cHggcmdiYSgwLDAsMCwwLjMpJztcclxuXHJcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtlclxyXG4gICAgICAgIGNvbnN0IG1hcmtlciA9IG5ldyB3aW5kb3cubWFwYm94Z2wuTWFya2VyKGVsKVxyXG4gICAgICAgICAgLnNldExuZ0xhdChbZXZlbnQubG9uZ2l0dWRlLCBldmVudC5sYXRpdHVkZV0pXHJcbiAgICAgICAgICAuc2V0UG9wdXAoXHJcbiAgICAgICAgICAgIG5ldyB3aW5kb3cubWFwYm94Z2wuUG9wdXAoeyBvZmZzZXQ6IDI1IH0pXHJcbiAgICAgICAgICAgICAgLnNldEhUTUwoYDxkaXYgc3R5bGU9XCJwYWRkaW5nOiA4cHg7XCI+PHN0cm9uZz4ke2V2ZW50Lm5hbWV9PC9zdHJvbmc+PGJyLz4ke2V2ZW50LmxvY2F0aW9ufTwvZGl2PmApXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgICAuYWRkVG8obWFwKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGNsaWNrIGV2ZW50XHJcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XHJcbiAgICAgICAgICBvbkV2ZW50Q2xpY2s/LihldmVudCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIG1hcmtlcnNSZWYuY3VycmVudC5wdXNoKG1hcmtlcik7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8vIEluaXRpYWxpemUgbWFwIG9uY2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKCFtYXBSZWYuY3VycmVudCB8fCBtYXBJbnN0YW5jZVJlZi5jdXJyZW50KSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgYXBpS2V5ID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfTUFQQk9YX0FDQ0VTU19UT0tFTiB8fCAncGsuZXlKMUlqb2libWx1YW1GelkyaHZiMnd6TnlJc0ltRWlPaUpqYldzNWRXRnNOMjh4ZG5CcU0yVnZkVEYxZG0xNWR6UjJJbjAuTG5maEZOZzlKckdWT1dkR1dqRTRLQSc7XHJcbiAgICBjb25zdCBkZWZhdWx0Q2VudGVyID0gY2VudGVyIHx8IHsgbGF0OiAxMC44MjMxLCBsbmc6IDEwNi42Mjk3IH07IC8vIEhvIENoaSBNaW5oIENpdHlcclxuXHJcbiAgICBjb25zdCBsb2FkTWFwYm94ID0gKCkgPT4ge1xyXG4gICAgICAvLyBMb2FkIE1hcGJveCBHTCBDU1MgYW5kIEpTXHJcbiAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hcGJveC1nbC1jc3MnKSkge1xyXG4gICAgICAgIGNvbnN0IGNzcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKTtcclxuICAgICAgICBjc3MuaWQgPSAnbWFwYm94LWdsLWNzcyc7XHJcbiAgICAgICAgY3NzLmhyZWYgPSAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9tYXBib3gtZ2wtanMvdjIuMTUuMC9tYXBib3gtZ2wuY3NzJztcclxuICAgICAgICBjc3MucmVsID0gJ3N0eWxlc2hlZXQnO1xyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoY3NzKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKCF3aW5kb3cubWFwYm94Z2wpIHtcclxuICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcclxuICAgICAgICBzY3JpcHQuc3JjID0gJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3YyLjE1LjAvbWFwYm94LWdsLmpzJztcclxuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuXHJcbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9ICgpID0+IHtcclxuICAgICAgICAgIGluaXRNYXBib3goKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGluaXRNYXBib3goKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBpbml0TWFwYm94ID0gKCkgPT4ge1xyXG4gICAgICBpZiAoIXdpbmRvdy5tYXBib3hnbCB8fCAhbWFwUmVmLmN1cnJlbnQpIHJldHVybjtcclxuXHJcbiAgICAgIC8vIFNldCBhY2Nlc3MgdG9rZW5cclxuICAgICAgaWYgKGFwaUtleSkge1xyXG4gICAgICAgIHdpbmRvdy5tYXBib3hnbC5hY2Nlc3NUb2tlbiA9IGFwaUtleTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5pdGlhbGl6ZSBtYXBcclxuICAgICAgY29uc3QgbWFwID0gbmV3IHdpbmRvdy5tYXBib3hnbC5NYXAoe1xyXG4gICAgICAgIGNvbnRhaW5lcjogbWFwUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgc3R5bGU6ICdtYXBib3g6Ly9zdHlsZXMvbWFwYm94L3N0cmVldHMtdjEyJyxcclxuICAgICAgICBjZW50ZXI6IFtkZWZhdWx0Q2VudGVyLmxuZywgZGVmYXVsdENlbnRlci5sYXRdLFxyXG4gICAgICAgIHpvb206IHpvb20sXHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG1hcDtcclxuXHJcbiAgICAgIC8vIFdhaXQgZm9yIG1hcCB0byBsb2FkXHJcbiAgICAgIG1hcC5vbignbG9hZCcsICgpID0+IHtcclxuICAgICAgICBtYXBMb2FkZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgYWRkTWFya2Vyc1RvTWFwKG1hcCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBsb2FkTWFwYm94KCk7XHJcblxyXG4gICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgLy8gQ2xlYW51cCBtYXJrZXJzIGFuZCBtYXBcclxuICAgICAgbWFya2Vyc1JlZi5jdXJyZW50LmZvckVhY2goKG1hcmtlcikgPT4ge1xyXG4gICAgICAgIG1hcmtlci5yZW1vdmUoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIG1hcmtlcnNSZWYuY3VycmVudCA9IFtdO1xyXG4gICAgICBpZiAobWFwSW5zdGFuY2VSZWYuY3VycmVudCkge1xyXG4gICAgICAgIG1hcEluc3RhbmNlUmVmLmN1cnJlbnQucmVtb3ZlKCk7XHJcbiAgICAgICAgbWFwSW5zdGFuY2VSZWYuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgbWFwTG9hZGVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9LCBbXSk7IC8vIE9ubHkgcnVuIG9uY2Ugb24gbW91bnRcclxuXHJcbiAgLy8gVXBkYXRlIG1hcmtlcnMgd2hlbiBldmVudHMgY2hhbmdlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGlmIChtYXBJbnN0YW5jZVJlZi5jdXJyZW50ICYmIG1hcExvYWRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIGFkZE1hcmtlcnNUb01hcChtYXBJbnN0YW5jZVJlZi5jdXJyZW50KTtcclxuICAgIH1cclxuICB9LCBbZXZlbnRzLCBvbkV2ZW50Q2xpY2tdKTtcclxuXHJcbiAgLy8gVXBkYXRlIG1hcCBjZW50ZXIgYW5kIHpvb20gd2hlbiBwcm9wcyBjaGFuZ2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYgKG1hcEluc3RhbmNlUmVmLmN1cnJlbnQgJiYgY2VudGVyICYmIG1hcExvYWRlZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIG1hcEluc3RhbmNlUmVmLmN1cnJlbnQuZmx5VG8oe1xyXG4gICAgICAgIGNlbnRlcjogW2NlbnRlci5sbmcsIGNlbnRlci5sYXRdLFxyXG4gICAgICAgIHpvb206IHpvb20sXHJcbiAgICAgICAgZHVyYXRpb246IDEwMDAsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0sIFtjZW50ZXIsIHpvb21dKTtcclxuXHJcbiAgcmV0dXJuIDxkaXYgcmVmPXttYXBSZWZ9IGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGxcIiBzdHlsZT17eyBtaW5IZWlnaHQ6ICc0MDBweCcgfX0gLz47XHJcbn1cclxuXHJcbi8vIEV4dGVuZCBXaW5kb3cgaW50ZXJmYWNlXHJcbmRlY2xhcmUgZ2xvYmFsIHtcclxuICBpbnRlcmZhY2UgV2luZG93IHtcclxuICAgIG1hcGJveGdsOiBhbnk7XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJNYXBDb21wb25lbnQiLCJldmVudHMiLCJvbkV2ZW50Q2xpY2siLCJjZW50ZXIiLCJ6b29tIiwibWFwUmVmIiwibWFwSW5zdGFuY2VSZWYiLCJtYXJrZXJzUmVmIiwibWFwTG9hZGVkUmVmIiwiYWRkTWFya2Vyc1RvTWFwIiwibWFwIiwiY3VycmVudCIsImZvckVhY2giLCJtYXJrZXIiLCJyZW1vdmUiLCJldmVudCIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiZWwiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJjbGFzc05hbWUiLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwiYm9yZGVyUmFkaXVzIiwiYmFja2dyb3VuZENvbG9yIiwiYm9yZGVyIiwiY3Vyc29yIiwiYm94U2hhZG93Iiwid2luZG93IiwibWFwYm94Z2wiLCJNYXJrZXIiLCJzZXRMbmdMYXQiLCJzZXRQb3B1cCIsIlBvcHVwIiwib2Zmc2V0Iiwic2V0SFRNTCIsIm5hbWUiLCJsb2NhdGlvbiIsImFkZFRvIiwiYWRkRXZlbnRMaXN0ZW5lciIsInB1c2giLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfTUFQQk9YX0FDQ0VTU19UT0tFTiIsImRlZmF1bHRDZW50ZXIiLCJsYXQiLCJsbmciLCJsb2FkTWFwYm94IiwiZ2V0RWxlbWVudEJ5SWQiLCJjc3MiLCJpZCIsImhyZWYiLCJyZWwiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJzY3JpcHQiLCJzcmMiLCJhc3luYyIsIm9ubG9hZCIsImluaXRNYXBib3giLCJhY2Nlc3NUb2tlbiIsIk1hcCIsImNvbnRhaW5lciIsIm9uIiwiZmx5VG8iLCJkdXJhdGlvbiIsImRpdiIsInJlZiIsIm1pbkhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/MapComponent.tsx\n"));

/***/ })

}]);